<script>
  var cardData;
  var colors;  // needed later
  const urlParams = new URLSearchParams(window.location.search);  // TODO: global

  const getInnerText = function(node) {
    // helper function for the table sorting algorithm
    // TODO: SLOW

    if (node === undefined) return;

    let childNodes = node.childNodes;

    let textContent = '';
    for(var i = 0; i < childNodes.length; i++) {
        if(childNodes[i].nodeType==3) {
          textContent += childNodes[i].data;
        } else if (childNodes[i].nodeType==1) {
          textContent += getInnerText(childNodes[i]);
        }
    }
    // replace line breaks, single tabs, and whitespace > length 2
    // TODO is this caused by EJS?
    textContent = textContent.replace(/\r?\n|\r|\t|\s{2,}/g,"");

    return textContent;
  }

  function isNumeric(str) {
    // https://stackoverflow.com/questions/175739/how-can-i-check-if-a-string-is-a-valid-number
    if (typeof str != "string") return false // we only process strings!  
    return !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...
          !isNaN(parseFloat(str)) // ...and ensure strings of whitespace fail
  }


  /* 
    ---------- DRAG AND DROP -------------
  */

  // https://www.w3schools.com/HTML/html5_draganddrop.asp
  // https://stackoverflow.com/questions/13007582/html5-drag-and-copy

  const allowDrop = function(ev) {
    ev.preventDefault();
  }
  

  const drag = function(ev) {
    if (ev.target.tagName === 'TR') {
      // User drags the row
      ev.dataTransfer.setData("text", ev.target.id);
    } else if (ev.target.tagName === 'A') {
      // user drags one of the hyperlink elements in the table
      ev.dataTransfer.setData("text", ev.target.parentNode.parentNode.parentNode.id);
    }
  }


  const checkInTable = function(data, tBody) {
    // checks if an element is already in the table

    let index = 0;

    for (const row of tBody.children) {
      // compare first row (unique identifier)
      if (row.children.item(0).textContent === data.children.item(0).textContent) {
        break;
      }
      index++;
    }

    if (index === tBody.children.length) index = -1;

    return index;
  }


  const drop = function(ev) {
    ev.preventDefault();

    let data = ev.dataTransfer.getData("text");
    let newRow = document.getElementById(data);

    let dropped = false;


    // check which zone the element is dragged onto
    if (ev.target.className === 'drag-zone') {
      // check for the parent div
      let tBody = ev.target.parentNode.getElementsByTagName('tbody')[0];

      // check if element is in table and at which index
      let index = checkInTable(document.getElementById(data), tBody);

      if (index === -1) {
        // put row in table
        tBody.appendChild(newRow);
        dropped = true;
      }
    }
    // column with an X lets you remove the element
    if (dropped) {
      addColumnsToCard(newRow);
      updateStats()
    }
  }


  const addToDeckTable = async function(event) {
    // adds the row of card data to the Deck table
    // the row is retrieved from the drag event's parent
    let newRow = event.target.parentNode;
    let tBody = document.getElementById('my-deck-table').getElementsByTagName('tbody')[0];
    addColumnsToCard(newRow);
    tBody.appendChild(newRow);

    // add the card also to local storage
    await addCardFromDeckbuilder(newRow);

    // update the Stats element of the page
    updateStats();
  }


  var removeFromDeckTable = function(event) {
    // add this row of card data back to the "All cards" table
    let row = event.target.parentNode;

    // if it was a leader and there is an image
    if (row.parentNode.parentNode.id === 'leader-container-table') {
        document.getElementById('leader-image').remove();
      }

    // remove the X and the Leader column
    row.removeChild(row.lastElementChild);
    row.removeChild(row.lastElementChild);

    // add the "add to deck" column
    let addCell = document.createElement('td');
    addCell.className = 'add-deck';
    addCell.textContent = String.fromCodePoint(10133);
    addCell.setAttribute('onclick', 'addToDeckTable(event)');
    row.appendChild(addCell);

    // move back to all cards list
    let galleryTBody = document.getElementById('card-gallery-table')
        .getElementsByTagName('tbody')[0];
    
    galleryTBody.insertBefore(row, galleryTBody.firstChild);

    // remove from deck in local storage
    let id = row.dataset.cardid;
    removeCardFromDeck(id);
    console.log('removed', id);

    updateStats();
  }


  const handleLeaderCheckbox = function(event) {
    let currentDeckID = localStorage.getItem('currentDeckID');
    let deck = getDeck(currentDeckID);

    // uncheck all boxes, then check the selected box
    let boxes = document.querySelectorAll('.leader-checkbox');
    boxes.forEach(box => {
      box.checked = false;
      // change the leader status in the card object
      deck.cards[box.dataset.id].leader = false;
    });
    
    event.target.checked = true;

    // set leader in the deck object
    let leaderID = event.target.dataset.id;

    deck.leader = deck.cards[leaderID];
    deck.cards[leaderID].leader = true;
    saveDeck(deck, currentDeckID);
  }


  const addColumnsToCard = function(row, setAsLeader=false) {
    // this has to be called when a card is added to the Deck table

    // remove the "add to deck" column
    row.removeChild(row.lastElementChild);

    // Add the "Captain?" checkbox
    let leaderCheckCell = document.createElement('td');
    let leaderCheckbox = document.createElement('input');
    leaderCheckbox.type = 'checkbox';
    leaderCheckbox.className = 'leader-checkbox';
    leaderCheckbox.id = `leader-checkbox-${row.dataset.cardid}`;
    leaderCheckbox.setAttribute('onChange', 'handleLeaderCheckbox(event)');
    // data attribute
    leaderCheckbox.dataset.id = row.dataset.cardid;

    if (setAsLeader) {
      leaderCheckbox.checked = true;
    }

    leaderCheckCell.appendChild(leaderCheckbox);
    row.appendChild(leaderCheckCell);

    // add the "X" column that will remove this row from the deck
    let xCell = document.createElement('td');
    xCell.className = 'remove-x';
    xCell.textContent = String.fromCodePoint(10060);

    xCell.setAttribute('onclick', 'removeFromDeckTable(event)');

    row.appendChild(xCell);
  }


  /* 
      ------- TABLE SORTING ---------
  */
  // https://stackoverflow.com/questions/59282842/how-to-make-sorting-html-tables-faster
  function sortTableRowsByColumn(table, columnIndex, ascending) {

  const rows = Array.from( table.querySelectorAll( ':scope > tbody > tr' ) );

  rows.sort( ( x, y ) => {

      // try converting to a float
      let xValue = x.cells[columnIndex].textContent;
      let yValue = y.cells[columnIndex].textContent;

      if (isNumeric(xValue) && isNumeric(yValue)) {
        xValue = parseFloat(xValue);
        yValue = parseFloat(yValue);
      }

      return ascending ? ( xValue > yValue ) : ( yValue > xValue ); // <-- Neat comparison trick.
  } );

  // There is no need to remove the rows prior to adding them in-order because `.appendChild` will relocate existing nodes.
  for( let row of rows ) {
      table.tBodies[0].appendChild( row );
  }
  }

  function onColumnHeaderClicked(ev) {
    const th = ev.currentTarget;
    const table = th.closest( 'table' );
    
    const thIndex = Array.from( th.parentElement.children ).indexOf( th );


    const ascending = th.dataset.sort != 'asc';

    sortTableRowsByColumn( table, thIndex, ascending );

    const allTh = table.querySelectorAll( ':scope > thead > tr > th' );
    for( let th2 of allTh ) {
      delete th2.dataset['sort'];
    }

    th.dataset['sort'] = ascending ? 'asc' : 'desc';
  }


  // --- MISC -----

  const imageErrorHandler = function(img) {
    // load a local default image on Error
    img.src = '/images/notfound.png';
  }


  const capitalize = function(str) {
    // capitalize the first char of a string
    return str.charAt(0).toUpperCase() + str.slice(1);
  }


  const getDeck = function(deckID) {
    if (deckID === undefined) { 
      deckID = localStorage.getItem('currentDeckID'); 
    }

    let blueprint = {
      id: deckID,
      cards: {},
      name: "Untitled Deck",
      leader: null,
      money: 0
    };

    // retrieves the current user created deck from local storage
    if (!localStorage.getItem(deckID)) {
      // if there is no currentDeck, set it as an empty array
      localStorage.setItem(deckID, JSON.stringify(blueprint));
    }
    // parse string from storage and return an object
    let deck = JSON.parse(localStorage.getItem(deckID));


    // test if deck object matches the blueprint
    // necessary if the users have an older version in the cache
    for (const key in blueprint) {
      if (!Object.keys(deck).includes(key)) {
        alert('Warning: The deck in your cache seems to be an older version. Deck deleted.')
        console.log(deck);
        deck = JSON.parse(JSON.stringify(blueprint));
        break;
      }
    }
    return deck;
  }


  const isInDeck = function(id) {
    return (id in getDeck().cards);
  }


  const saveDeck = function(deck, deckID) {
    if (deckID === undefined) { 
      deckID = 'deck-' + getIDnumber();
    }
    // puts the deck object back into local storage as string
    localStorage.setItem(deckID, JSON.stringify(deck));
  }


  const deleteDeck = function(deckID) {
    if (deckID === undefined) { 
      console.log('Cannot delete deck with undefined ID');
      return;
    }
    if (!localStorage.hasOwnProperty(deckID)) {
      console.log(`"${deckID}" does not exist in storage`);
      return;
    }
    // clears the decklist from local storage
    localStorage.removeItem(deckID);
  }

  
  const addCardtoDeck = async function(card) {
    // adds a new card to the deck in local storage

    if (cardData === undefined) {
      // fetch the card data once (into RAM)
      cardData = await getAllCards();
    }

    // retrieve the deck object
    let currentDeckID = localStorage.getItem('currentDeckID');
    let deck = getDeck(currentDeckID);

    // check if this card is in the deck
    let id = card.id;
    if (id in deck.cards) {
      // alert("This card is already in your deck!");
      return;
    }

    // combine with card data from database
    card.data = cardData[id];

    if (card.leader) {
      deck.leader = card;
    }
    deck.cards[id] = card;

    // put deck array back into storage
    saveDeck(deck, currentDeckID);
  }


  const removeCardFromDeck = function(id) {
    // removes a card from the deck in local storage

    // retrieve the deck object
    let currentDeckID = localStorage.getItem('currentDeckID');
    let deck = getDeck(currentDeckID);

    // check if this card is in the deck
    if (!(id in deck.cards)) {
      return;
    }
    delete deck.cards[id];

    // put deck array back into storage
    saveDeck(deck, currentDeckID);
  }


  const addCardfromSinglecard = function() {
    // Wrapper for addCardToDeck(), to be called from singlecard.ejs

    // get name of Card from singlecard.ejs

    // TODO: put card ID into the html data attribute?
    let path = window.location.pathname.split('/')

    let card = {
      name: document.querySelector('.card-title')?.innerHTML,
      id: path[path.length - 1],
      cardtype: document.querySelector('.card-type-text')?.getAttribute('data-cardtype'),
      info: 'ðŸ’¬',
      leader: false,
      data: null
    };

    addCardtoDeck(card);
    // hide the div that holds the "add to deck" function
    // TODO: animate instead
    document.getElementById('add-to-deck-container').style.display = "none";
  }


  const addCardFromDeckbuilder = async function(row) {
    // Wrapper for addCardToDeck(), to be called from deck-builder.ejs

    // add the card from the deck builder
    let name = getInnerText(row.firstElementChild);
    
    let card = {
      name: getInnerText(row.querySelector('.table-cell-cardname')),
      id: row.dataset.cardid,
      cardtype: getInnerText(row.querySelector('.table-cell-cardtype')),
      info: 'ðŸ’¬',
      leader: false,
      data: null
    };

    await addCardtoDeck(card);
  }


  const addCardAsLeader = function(row) {
    // Wrapper for addCardToDeck(), to be called from deck-builder.ejs

    // TODO: obsolete?

    // add the card from the deck builder
    let name = getInnerText(row.firstElementChild);
    
    let card = {
      name: getInnerText(row.querySelector('.table-cell-cardname')),
      id: row.dataset.cardid,
      cardtype: getInnerText(row.querySelector('.table-cell-cardtype')),
      info: 'ðŸ’¬',
      leader: true,
      data: null
    };

    addCardtoDeck(card);
  }


  const createDeckFromStorage = function() {
    // loads the deck from localstorage into the deck builder
    let currentDeckID = localStorage.getItem('currentDeckID');
    let deck = getDeck(currentDeckID);

    let galleryTBody = document.getElementById('card-gallery-table')
          .getElementsByTagName('tbody')[0];
    let deckTBody = document.getElementById('my-deck-table').getElementsByTagName('tbody')[0];

    Object.entries(deck.cards).forEach(([key, card]) => {
      let row = document.querySelector(`.card-gallery-row-${key}`);
      deckTBody.appendChild(row);
      addColumnsToCard(row, card.leader);
    });

    // Money
    let moneySelect = document.getElementById('num-money');
    moneySelect.value = deck.money;

    console.log('deck creation done')

    // change Title
    let title = document.querySelector('#deck-title');
    title.textContent = truncateDeckName(deck.name) || 'Untitled Deck';
  }


  const getAllCards = async function() {
    // get all cards from Database
    let response = await fetch("/api/all-cards");
    let data = await response.json();

    cards = {};
    // reformat with id as keys
    data.forEach(card => {
      cards[card.id] = card;
    });

    return cards;
  }


  const download = function(content, fileName, contentType) {
    // generic client-side download
    let a = document.createElement("a");
    let file = new Blob([content], {type: contentType});
    a.href = URL.createObjectURL(file);
    a.download = fileName;
    a.click();
  }


  const exportDeckTxtNew = function(deck) {
    let valid = true;  // if the deck is valid for export
    let errorMsg = [];

    let txt = `[deck="${deck.name}"]\n`;
    
    // get leader name
    const leader = deck.leader?.data.name;
    if (!leader) {
      valid = false;
      errorMsg.push('- Your deck has to have a Captain!');
    }
    txt += `//Captain\n${leader}\n\n//Deck\n`;

    Object.entries(deck.cards).forEach(([key, card]) => {
      if(!card.leader) {
        txt += `1 ${card.data.name}\n`;
      }
    });

    const money = deck.money;
    txt += `${money} Money`;

    // deck legality check (rows.length starting at one and the leader cancel out)
    let decklen = Object.entries(deck.cards).length + parseInt(money);
    if (decklen < 45) {
      valid = false;
      errorMsg.push(`- Your deck doesn\'t have enough cards (${decklen}/45)`);
    }

    if (!valid) {
      alert('Your deck is invalid for these reasons:\n' + errorMsg.join('\n'));
      return '';
    }
    return txt;
  }


  const downloadDeckString = function() {
    const deck = getDeck(currentDeckID);
    let deckString = exportDeckTxtNew(deck);
    let filename = `${deck.name.replace(/[.\s]+/g, "_").toLowerCase()}.txt`;
    download(deckString, filename, 'text/csv;charset=utf-8;');
  }


  const getIDnumber = function() {
    // creates a new unique deck id number
    let ids = Object.keys(localStorage);
    ids = ids.filter(elem => elem !== 'currentDeckID');
    ids = ids.map(elem => elem.split('-')[1]).sort();

    if (ids.length === 0) {
      console.log('Nothing in local storage')
      return 0;
    }

    return parseInt(ids[ids.length-1]) + 1;
  }


  const loadDeckFromFile = async function(deckString, name="", id) {
    if (id === undefined) { 
      id = 'deck-' + getIDnumber();
    };

    let errors = [];
    // check if string has deck name information
    let deckNameMatch = deckString.match(/\[deck\=\"(.+)\"/);
    if (deckNameMatch) {
      name = deckNameMatch[1];
    }

    let leader = deckString.match(/\/\/Captain\s*(.+)\s/)?.[1];
    if (leader === undefined) {
      errors.push('- List ist missing a Captain.');
    }

    let rawCards = deckString.match(/\/\/Deck\s*(.+)/s)?.[1].split(/\r?\n/);
    rawCards = rawCards.slice(1, rawCards.length);

    if (cardData === undefined) {
      // fetch the card data once (into RAM)
      cardData = await getAllCards();
    }

    let deck = getDeck(id);
    deck.name = name;
    let cards = rawCards.map(elem => elem.split(/[0-9]+\s/)[1]);
    cards.push(leader);
    
    for (const cardname of cards) {
      if (cardname === undefined) {
        errors.push('- Unidentified card name.');
        continue;
      }

      // guess id from cardname
      let idGuess = cardname.toLowerCase()
        .replace('.', '')
        .replace(/[.\s-]+/g, '_')
        // replace umlauts
        .replace('Ã¤', 'ae')
        .replace('Ã¶', 'oe')
        .replace('Ã¼', 'ue');

      if (idGuess === 'money') {
        deck.money = deckString.match(/([0-9]+)\sMoney/)[1];
      } else {
        let card = {
          id: idGuess,
          leader: cardname === leader ? true : false
        };
        card.data = cardData[idGuess];
        card.name = card.data.name;
        deck.cards[idGuess] = card;

        if (card.leader) { deck.leader = card }
      }
    }

    if (errors.length > 0) {
      // TODO make alert optional
      alert('Invalid or corrupted file:\n' + errors.join('\n'));
      return;
    }
    saveDeck(deck, id);
  }


  const updateStats = function() {
    console.log('deck stats updated')
    // Update visualized deck statistics in the deck builder
    const money = parseInt(document.getElementById('num-money').value);

    let currentDeckID = localStorage.getItem('currentDeckID');
    let deck = getDeck(currentDeckID);
    const cardsTotal = Object.keys(deck.cards).length + money;

    let typeCount = {
      Fighter: 0,
      Item: 0,
      Landscape: 0,
      Challenge: 0
    };

    let totalHire = 0;
    let totalFire = 0;

    Object.entries(deck.cards).forEach(([key, card]) => {
      typeCount[card.cardtype]++;

      let hire = parseInt(card.data.hire);
      let fire = parseInt(card.data.fire);
      totalHire += Number.isFinite(hire) ? hire : 0;
      totalFire += Number.isFinite(fire) ? fire : 0;
    });

    let avgHire;
    if (cardsTotal === 0) {
      avgHire = "0"
    } else {
      avgHire = (totalHire / cardsTotal).toFixed(1);
    }

    let statsTxt1 = `Cards total: ${cardsTotal}<br>
    Fighters: ${typeCount.Fighter}<br>
    Items: ${typeCount.Item}<br>
    Landscapes: ${typeCount.Landscape}`;

    let statsTxt2 = `Challenges: ${typeCount.Challenge}<br>
    Money: ${money}<br>
    Average Hire costs: ${avgHire}<br>
    Total Fire costs: ${totalFire}`;

    document.getElementById('deck-stats').innerHTML = '';

    let p1 = document.createElement('p');
    let p2 = document.createElement('p');

    p1.innerHTML = statsTxt1;
    p2.innerHTML = statsTxt2;

    document.getElementById('deck-stats').appendChild(p1);
    document.getElementById('deck-stats').appendChild(p2);

    // add money info to deck in storage
    deck.money = money;
    saveDeck(deck, currentDeckID);
  }


  const truncateDeckName = function(rawName, maxSize=30) {
    // truncates the deck name string for display
    if (rawName === null || rawName.length === 0) return "Untitled Deck";

    if (rawName.length <= maxSize) return rawName;

    return rawName.slice(0, maxSize) + '[...]';
  }

  const load = async function(url) {
    try {
      const response = await fetch(url);
      const text = await response.text();
      return text;
    } catch (err) {
      console.error(err);
    }
  }

  const loadPreconFile = async function(url, id) {
    text = await load(url);
    loadDeckFromFile(text, null, id);
    localStorage.setItem('currentDeckID', id);
  }


</script>
