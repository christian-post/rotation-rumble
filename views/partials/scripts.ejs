<script>

  var colors;  // needed later

  function getInnerText(node) {
    // helper function for the table sorting algorithm
    // TODO: import from exportCSV.js?
    let childNodes = node.childNodes;

    let textContent = '';
    for(var i = 0; i < childNodes.length; i++) {
        if(childNodes[i].nodeType==3) {
          textContent += childNodes[i].data;
        } else if (childNodes[i].nodeType==1) {
          textContent += getInnerText(childNodes[i]);
        }
    }
    // replace line breaks, single tabs, and whitespace > length 2
    textContent = textContent.replace(/\r?\n|\r|\t|\s{2,}/g,"");

    return textContent;
  }


  /* 
    ---------- DRAG AND DROP -------------
  */

  // https://www.w3schools.com/HTML/html5_draganddrop.asp
  // https://stackoverflow.com/questions/13007582/html5-drag-and-copy

  function allowDrop(ev) {
    ev.preventDefault();
  }
  

  function drag(ev) {
    if (ev.target.tagName === 'TR') {
      // User drags the row
      ev.dataTransfer.setData("text", ev.target.id);
    } else if (ev.target.tagName === 'A') {
      // user drags one of the hyperlink elements in the table
      ev.dataTransfer.setData("text", ev.target.parentNode.parentNode.parentNode.id);
    }
  }


  function checkInTable(data, tBody) {
    // checks if an element is already in the table

    let index = 0;

    for (const row of tBody.children) {
      // compare first row (unique identifier)
      if (row.children.item(0).textContent === data.children.item(0).textContent) {
        break;
      }
      index++;
    }

    if (index === tBody.children.length) index = -1;

    return index;
  }


  function drop(ev) {
    ev.preventDefault();

    let data = ev.dataTransfer.getData("text");
    let newRow = document.getElementById(data);

    let dropped = false;

   

    // check which zone the element is dragged onto
    if (ev.target.className === 'drag-zone') {
      // check for the parent div
      let tBody = ev.target.parentNode.getElementsByTagName('tbody')[0];

      if (ev.target.parentNode.className === 'leader-container') {
        // element gets dragged into the container for the deck's leader

        // check if the dragged card is a Fighter
        if (newRow.children.item(1).innerText !== 'Fighter') {
          alert('Your Leader has to be a Fighter!');
          return;
        }

        // check if something is already in there
        if (tBody.children.length === 1) {
          alert('You already selected a Leader!');
          return;
        }

        // leader image

        // check if there is already an image
        if (document.getElementById('leader-image')) {
          document.getElementById('leader-image').remove();
        }

        // read image url from img tag
        let imageSrc = newRow.querySelector('.card-image-tooltip')?.src;

        let leaderImg = document.createElement('img');
        leaderImg.id = 'leader-image';
        leaderImg.src = imageSrc || 'images/notfound.png';
        leaderImg.width = '300';
        ev.target.parentNode.appendChild(leaderImg);

        tBody.appendChild(newRow);
        dropped = true;

      } else if (ev.target.parentNode.className === 'deck-container') {
        // check if element is in table and at which index
        let index = checkInTable(document.getElementById(data), tBody);

        if (index === -1) {
          // put row in table
          tBody.appendChild(newRow);
          dropped = true;
        }
      }
    }
    // column with an X lets you remove the element
    if (dropped) {
      addColumnsToCard(newRow);
    }
  }


  function addToDeck(event) {
    // adds the row of data to the Deck table
    let newRow = event.target.parentNode;
    let tBody = document.getElementById('my-deck-table').getElementsByTagName('tbody')[0];
    addColumnsToCard(newRow);
    tBody.appendChild(newRow);

    // add to local storage
    
    addCardFromDeckbuilder(newRow);
  }


  function addColumnsToCard(row) {
    // when a card is added to the Deck table

    // remove the "add to deck" column
    row.removeChild(row.lastElementChild);

    let xCol = document.createElement('td');
    xCol.className = 'remove-x';
    xCol.textContent = String.fromCodePoint(10060);

    xCol.onclick = () => {
      // when the card is added back to the All Cards table

      // if it was a leader and there is an image

      if (row.parentNode.parentNode.id === 'leader-container-table') {
          document.getElementById('leader-image').remove();
        }

      // remove the X column
      row.removeChild(row.lastElementChild);

      // add the "add to deck" column
      let addCol = document.createElement('td');
      addCol.className = 'add-deck';
      addCol.textContent = String.fromCodePoint(10133);
      addCol.setAttribute('onclick', 'addToDeck(event)');
      row.appendChild(addCol);

      // move back to all cards list
      let galleryTBody = document.getElementById('card-gallery-table')
          .getElementsByTagName('tbody')[0];
      
      galleryTBody.insertBefore(row, galleryTBody.firstChild);
    }

    row.appendChild(xCol);
  }



  /* 
      ------- TABLE SORTING ---------
  */
  function sortTable(index, id) {
    // https://www.w3schools.com/howto/howto_js_sort_table.asp

    let table = document.getElementById(id);
    
    //Set the sorting direction to ascending:
    let dir = 'asc';

    /*Make a loop that will continue until
    no switching has been done:*/

    let rows, i, x, y, shouldSwitch;
    let switchcount = 0;
    let switching = true;

    while (switching) {
      //start by saying: no switching is done:
      switching = false;
      rows = table.rows;
      /*Loop through all table rows (except the
      first, which contains table headers):*/
      for (i = 1; i < (rows.length - 1); i++) {
        //start by saying there should be no switching:
        shouldSwitch = false;
        /*Get the two elements you want to compare,
        one from current row and one from the next:*/
        x = rows[i].getElementsByTagName('TD')[index];
        y = rows[i + 1].getElementsByTagName('TD')[index];
        /*check if the two rows should switch place,
        based on the direction, asc or desc:*/
        if (dir == 'asc') {
          if (getInnerText(x).toLowerCase() > getInnerText(y).toLowerCase()) {
            //if so, mark as a switch and break the loop:
            shouldSwitch= true;
            break;
          }
        } else if (dir == 'desc') {
          if (getInnerText(x).toLowerCase() < getInnerText(y).toLowerCase()) {
            //if so, mark as a switch and break the loop:
            shouldSwitch = true;
            break;
          }
        }
      }
      if (shouldSwitch) {
        /*If a switch has been marked, make the switch
        and mark that a switch has been done:*/
        rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
        switching = true;
        //Each time a switch is done, increase this count by 1:
        switchcount ++;      
      } else {
        /*If no switching has been done AND the direction is 'asc',
        set the direction to 'desc' and run the while loop again.*/
        if (switchcount == 0 && dir == 'asc') {
          dir = 'desc';
          switching = true;
        }
      }
    }
  }

  // --- MISC -----

  function imageErrorHandler(img) {
    // load a local default image
    img.src = '/images/notfound.png';
  }


  function capitalize(str) {
    // capitalize the first char of a string
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  
  function idFromCardname(name) {
    // converts a card name to its id
    return name.replace(new RegExp('[\\s-]', 'gi'), '_').toLowerCase();
  }


  function getDeck() {
    if (!localStorage.getItem('currentDeck')) {
      // if there is no currentDeck, set it as an empty array
      localStorage.setItem('currentDeck', JSON.stringify({}));
    }
    // parse string from storage
    return JSON.parse(localStorage.getItem('currentDeck'));
  }

  
  function addCardtoDeck(cardData) {
    // adds the currently displayed card on singlecard.ejs to local storage
    let deck = getDeck();

    // check if this card is in the deck
    let key = idFromCardname(cardData.name);
    if (key in deck) {
      alert("This card is already in your deck!");
      return;
    }
    deck[key] = cardData;

    // put deck array back into storage
    localStorage.setItem('currentDeck', JSON.stringify(deck));
    // alert(`You added ${cardData.name}.\nGo to the Deck Builder page to see the whole deck!`);

    console.log(deck)
  }


  function addCardfromSinglecard() {
    // get name of Card from singlecard.ejs
    let card = {
      name: document.querySelector('.card-title')?.innerHTML,
      cardtype: document.querySelector('.card-type-text')?.getAttribute('data-cardtype'),
      info: 'ðŸ’¬'
    };
    addCardtoDeck(card);
    // hide the div that holds the "add to deck" function
    document.getElementById('add-to-deck-container').style.display = "none";
  }


  function addCardFromDeckbuilder(row) {
    // add the card from the deck builder

    let name = getInnerText(row.firstElementChild);
    
    let card = {
      name: getInnerText(row.querySelector('.table-cell-cardname')),
      cardtype: getInnerText(row.querySelector('.table-cell-cardtype')),
      info: 'ðŸ’¬'
    };
    addCardtoDeck(card);
  }


  function createDeckFromStorage() {
    // loads the deck from localstorage into the deck builder
    let deck = getDeck();

    console.log(deck)

    let galleryTBody = document.getElementById('card-gallery-table')
          .getElementsByTagName('tbody')[0];
    let deckTBody = document.getElementById('my-deck-table').getElementsByTagName('tbody')[0];

    Object.entries(deck).forEach(([key, card]) => {
      let row = document.querySelector(`.card-gallery-row-${key}`);
      addColumnsToCard(row);
      console.log(row)
      deckTBody.appendChild(row);
    });
  }

</script>
