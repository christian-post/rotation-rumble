<script>
  function getInnerText(node) {
    // helper function for the table sorting algorithm
    // TODO: import from exportCSV.js?
    let childNodes = node.childNodes;

    let textContent = '';
    for(var i = 0; i < childNodes.length; i++) {
        if(childNodes[i].nodeType==3) {
          textContent += childNodes[i].data;
        } else if (childNodes[i].nodeType==1) {
          textContent += getInnerText(childNodes[i]);
        }
    }
    textContent = textContent.replace(/\r?\n|\r/g,"");
    textContent = textContent.replace(/\s/g, "");  // whitespace

    return textContent;
  }


  /* 
    ---------- DRAG AND DROP -------------
  */

  // https://www.w3schools.com/HTML/html5_draganddrop.asp
  // https://stackoverflow.com/questions/13007582/html5-drag-and-copy

  function allowDrop(ev) {
    ev.preventDefault();
  }
  

  function drag(ev) {
    if (ev.target.localName === 'tr') {
      // User drags the row
      ev.dataTransfer.setData("text", ev.target.id);
    } else if (ev.target.localName === 'a') {
      // user drags one of the hyperlink elements in the table
      ev.dataTransfer.setData("text", ev.target.parentNode.parentNode.id);
    }
  }


  function checkInTable(data, tBody) {
    // checks if an element is already in the table

    let index = 0;

    for (const row of tBody.children) {
      // compare first row (unique identifier)
      if (row.children.item(0).textContent === data.children.item(0).textContent) {
        break;
      }
      index++;
    }

    if (index === tBody.children.length) index = -1;

    return index;
  }
  

  function drop(ev) {
    // TODO: Too much duplicate code!

    ev.preventDefault();

    var data = ev.dataTransfer.getData("text");

    if (ev.target.className === 'deck-container') {
      // if the data is dragged onto one of the div.table-container elements
      // firstElementChild is the <table> element

      let tBody = ev.target.firstElementChild.getElementsByTagName('tbody')[0];

      // check if element is in table and at which index
      let index = checkInTable(document.getElementById(data), tBody)

      if (index === -1) {
        // put row in table
        tBody.appendChild(document.getElementById(data));
      }
    } else if (ev.target.tagName === 'TH') {
      // data is dragged onto the table header
      // and insterted as the 0th child of the tbody

      let tBody = ev.target.parentNode.parentNode.parentNode.children[1];

      let index = checkInTable(document.getElementById(data), tBody)

      if (index === -1) {
        tBody.insertBefore(document.getElementById(data), tBody.children[0]);
      }
    } else if (ev.target.tagName === 'TD') {
      // data is dragged onto one of the existing rows
      // inserted above the targetted row
      
      let tBody = ev.target.parentNode.parentNode.parentNode.children[1];

      let index = checkInTable(document.getElementById(data), tBody);

      if (index === -1) {
        let newIndex = ev.target.parentNode.rowIndex - 1; // table head has row index 0
        tBody.insertBefore(document.getElementById(data), tBody.children[newIndex]);
      }
    } else if (ev.target.className === 'leader-container') {
      let tBody = ev.target.firstElementChild.getElementsByTagName('tbody')[0];
      tBody.appendChild(document.getElementById(data));
    }
  }

  /* 
      ------- TABLE SORTING ---------
  */
  function sortTable(index, id) {
    // https://www.w3schools.com/howto/howto_js_sort_table.asp
    
    var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
    table = document.getElementById(id);
    switching = true;
    //Set the sorting direction to ascending:
    dir = 'asc'; 
    /*Make a loop that will continue until
    no switching has been done:*/
    while (switching) {
      //start by saying: no switching is done:
      switching = false;
      rows = table.rows;
      /*Loop through all table rows (except the
      first, which contains table headers):*/
      for (i = 1; i < (rows.length - 1); i++) {
        //start by saying there should be no switching:
        shouldSwitch = false;
        /*Get the two elements you want to compare,
        one from current row and one from the next:*/
        x = rows[i].getElementsByTagName('TD')[index];
        y = rows[i + 1].getElementsByTagName('TD')[index];
        /*check if the two rows should switch place,
        based on the direction, asc or desc:*/
        if (dir == 'asc') {
          if (getInnerText(x).toLowerCase() > getInnerText(y).toLowerCase()) {
            //if so, mark as a switch and break the loop:
            shouldSwitch= true;
            break;
          }
        } else if (dir == 'desc') {
          if (getInnerText(x).toLowerCase() < getInnerText(y).toLowerCase()) {
            //if so, mark as a switch and break the loop:
            shouldSwitch = true;
            break;
          }
        }
      }
      if (shouldSwitch) {
        /*If a switch has been marked, make the switch
        and mark that a switch has been done:*/
        rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
        switching = true;
        //Each time a switch is done, increase this count by 1:
        switchcount ++;      
      } else {
        /*If no switching has been done AND the direction is 'asc',
        set the direction to 'desc' and run the while loop again.*/
        if (switchcount == 0 && dir == 'asc') {
          dir = 'desc';
          switching = true;
        }
      }
    }
  }

  // --- MISC -----

  function imageErrorHandler(img) {
    // load a local default image
    img.src = '/images/notfound.png';
  }

  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
</script>
