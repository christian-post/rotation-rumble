<script>
  var cardData;
  var colors;  // needed later


  const getInnerText = function(node) {
    // helper function for the table sorting algorithm
    // TODO: import from exportCSV.js instead?

    if (node === undefined) return;

    let childNodes = node.childNodes;

    let textContent = '';
    for(var i = 0; i < childNodes.length; i++) {
        if(childNodes[i].nodeType==3) {
          textContent += childNodes[i].data;
        } else if (childNodes[i].nodeType==1) {
          textContent += getInnerText(childNodes[i]);
        }
    }
    // replace line breaks, single tabs, and whitespace > length 2
    // TODO is this caused by EJS?
    textContent = textContent.replace(/\r?\n|\r|\t|\s{2,}/g,"");

    return textContent;
  }


  /* 
    ---------- DRAG AND DROP -------------
  */

  // https://www.w3schools.com/HTML/html5_draganddrop.asp
  // https://stackoverflow.com/questions/13007582/html5-drag-and-copy

  const allowDrop = function(ev) {
    ev.preventDefault();
  }
  

  const drag = function(ev) {
    if (ev.target.tagName === 'TR') {
      // User drags the row
      ev.dataTransfer.setData("text", ev.target.id);
    } else if (ev.target.tagName === 'A') {
      // user drags one of the hyperlink elements in the table
      ev.dataTransfer.setData("text", ev.target.parentNode.parentNode.parentNode.id);
    }
  }


  const checkInTable = function(data, tBody) {
    // checks if an element is already in the table

    let index = 0;

    for (const row of tBody.children) {
      // compare first row (unique identifier)
      if (row.children.item(0).textContent === data.children.item(0).textContent) {
        break;
      }
      index++;
    }

    if (index === tBody.children.length) index = -1;

    return index;
  }


  const drop = function(ev) {
    ev.preventDefault();

    let data = ev.dataTransfer.getData("text");
    let newRow = document.getElementById(data);

    let dropped = false;


    // check which zone the element is dragged onto
    if (ev.target.className === 'drag-zone') {
      // check for the parent div
      let tBody = ev.target.parentNode.getElementsByTagName('tbody')[0];

      if (ev.target.parentNode.className === 'leader-container') {
        // element gets dragged into the container for the deck's leader

        // check if the dragged card is a Fighter
        if (newRow.children.item(1).innerText !== 'Fighter') {
          alert('Your Leader has to be a Fighter!');
          return;
        }

        // check if something is already in there
        if (tBody.children.length === 1) {
          alert('You already selected a Leader!');
          return;
        }

        // show the leader image

        // check if there is already an image
        if (document.getElementById('leader-image')) {
          document.getElementById('leader-image').remove();
        }

        // read image url from img tag
        let imageSrc = newRow.querySelector('.card-image-tooltip')?.src;

        let leaderImg = document.createElement('img');
        leaderImg.id = 'leader-image';
        leaderImg.src = imageSrc || 'images/notfound.png';
        leaderImg.width = '300';
        ev.target.parentNode.appendChild(leaderImg);

        tBody.appendChild(newRow);
        dropped = true;

        addCardAsLeader(newRow);

      } else if (ev.target.parentNode.className === 'deck-container') {
        // check if element is in table and at which index
        let index = checkInTable(document.getElementById(data), tBody);

        if (index === -1) {
          // put row in table
          tBody.appendChild(newRow);
          dropped = true;
        }
      }
    }
    // column with an X lets you remove the element
    if (dropped) {
      addColumnsToCard(newRow);
    }
  }


  const addToDeckTable = function(event) {
    // adds the row of card data to the Deck table
    // the row is retrieved from the drag event's parent
    let newRow = event.target.parentNode;
    let tBody = document.getElementById('my-deck-table').getElementsByTagName('tbody')[0];
    addColumnsToCard(newRow);
    tBody.appendChild(newRow);

    // add the card also to local storage
    addCardFromDeckbuilder(newRow);

    updateStats();
  }


  var removeFromDeckTable = function(event) {
    // add this row of card data back to the "All cards" table
    let row = event.target.parentNode;

    // if it was a leader and there is an image
    if (row.parentNode.parentNode.id === 'leader-container-table') {
        document.getElementById('leader-image').remove();
      }

    // remove the X column
    row.removeChild(row.lastElementChild);

    // add the "add to deck" column
    let addCell = document.createElement('td');
    addCell.className = 'add-deck';
    addCell.textContent = String.fromCodePoint(10133);
    addCell.setAttribute('onclick', 'addToDeckTable(event)');
    row.appendChild(addCell);

    // move back to all cards list
    let galleryTBody = document.getElementById('card-gallery-table')
        .getElementsByTagName('tbody')[0];
    
    galleryTBody.insertBefore(row, galleryTBody.firstChild);

    // remove from deck in local storage
    let id = row.dataset.cardid;
    removeCardFromDeck(id);
    console.log('removed', id);

    updateStats();
  }


  const addColumnsToCard = function(row) {
    // this has to be called when a card is added to the Deck table

    // remove the "add to deck" column
    row.removeChild(row.lastElementChild);

    // add the "X" column that will remove this row from the deck
    let xCell = document.createElement('td');
    xCell.className = 'remove-x';
    xCell.textContent = String.fromCodePoint(10060);

    xCell.setAttribute('onclick', 'removeFromDeckTable(event)');

    row.appendChild(xCell);
  }


  const deleteDeckFromDeckbuilder = function() {
    if (!confirm('Do you want to delete this deck?')) return;

    // delete leader
    const leader = Array.from(document.getElementById('leader-container-table').rows)[0];
    leader?.querySelector('.remove-x')?.click();
    document.getElementById('leader-image')?.remove();

    // delete deck list
    const rows = Array.from(document.getElementById('my-deck-table').rows);
    // trigger onclick event of remove button
    rows.forEach(row => row.querySelector('.remove-x')?.click());
    // remove the deck from local storage
    deleteDeck();
  }

  

  /* 
      ------- TABLE SORTING ---------
  */
  const sortTable = function(index, id) {
    // https://www.w3schools.com/howto/howto_js_sort_table.asp

    let table = document.getElementById(id);
    
    //Set the sorting direction to ascending:
    let dir = 'asc';

    /*Make a loop that will continue until
    no switching has been done:*/

    let rows, i, x, y, shouldSwitch;
    let switchcount = 0;
    let switching = true;

    while (switching) {
      //start by saying: no switching is done:
      switching = false;
      rows = table.rows;
      /*Loop through all table rows (except the
      first, which contains table headers):*/
      for (i = 1; i < (rows.length - 1); i++) {
        //start by saying there should be no switching:
        shouldSwitch = false;
        /*Get the two elements you want to compare,
        one from current row and one from the next:*/
        x = rows[i].getElementsByTagName('TD')[index];
        y = rows[i + 1].getElementsByTagName('TD')[index];
        /*check if the two rows should switch place,
        based on the direction, asc or desc:*/
        if (dir == 'asc') {
          if (getInnerText(x).toLowerCase() > getInnerText(y).toLowerCase()) {
            //if so, mark as a switch and break the loop:
            shouldSwitch= true;
            break;
          }
        } else if (dir == 'desc') {
          if (getInnerText(x).toLowerCase() < getInnerText(y).toLowerCase()) {
            //if so, mark as a switch and break the loop:
            shouldSwitch = true;
            break;
          }
        }
      }
      if (shouldSwitch) {
        /*If a switch has been marked, make the switch
        and mark that a switch has been done:*/
        rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
        switching = true;
        //Each time a switch is done, increase this count by 1:
        switchcount ++;      
      } else {
        /*If no switching has been done AND the direction is 'asc',
        set the direction to 'desc' and run the while loop again.*/
        if (switchcount == 0 && dir == 'asc') {
          dir = 'desc';
          switching = true;
        }
      }
    }
  }

  // --- MISC -----

  const imageErrorHandler = function(img) {
    // load a local default image on Error
    img.src = '/images/notfound.png';
  }


  const capitalize = function(str) {
    // capitalize the first char of a string
    return str.charAt(0).toUpperCase() + str.slice(1);
  }


  const getDeck = function(deckID) {

    if (deckID === undefined) { deckID = 'currentDeck'; }

    let blueprint = {
      cards: {},
      name: "Untitled Deck",
      leader: null
    };

    // retrieves the current user created deck from local storage
    if (!localStorage.getItem(deckID)) {
      // if there is no currentDeck, set it as an empty array
      localStorage.setItem(deckID, JSON.stringify(blueprint));
    }
    // parse string from storage and return an object
    let deck = JSON.parse(localStorage.getItem(deckID));

    // test if deck object matches the blueprint
    // necessary if the users have an older version in the cache
    for (const key in blueprint) {
      if (!Object.keys(deck).includes(key)) {
        alert('Warning: The deck in your cache seems to be an older version. Deck deleted.')
        deck = JSON.parse(JSON.stringify(blueprint));
        break;
      }
    }

    return deck;
  }


  const isInDeck = function(id) {
    return (id in getDeck().cards);
  }


  const saveDeck = function(deck, deckID) {
    if (deckID === undefined) { deckID = 'currentDeck'; }
    // puts the deck object back into local storage as string
    localStorage.setItem(deckID, JSON.stringify(deck));
  }


  const deleteDeck = function(deckID) {
    if (deckID === undefined) { deckID = 'currentDeck'; }
    // clears the decklist from local storage
    localStorage.removeItem(deckID);
  }

  
  const addCardtoDeck = async function(card) {
    // adds a new card to the deck in local storage

    if (cardData === undefined) {
      // fetch the card data once (into RAM)
      cardData = await getAllCards();
    }

    // retrieve the deck object
    let deck = getDeck(currentDeckID);

    // check if this card is in the deck
    let id = card.id;
    if (id in deck.cards) {
      // alert("This card is already in your deck!");
      return;
    }

    // combine with card data from database
    card.data = cardData[id];

    if (card.leader) {
      deck.leader = card;
    }
    deck.cards[id] = card;

    // put deck array back into storage
    saveDeck(deck, currentDeckID);
  }


  const removeCardFromDeck = function(id) {
    // removes a card from the deck in local storage

    // retrieve the deck object
    let deck = getDeck(currentDeckID);

    // check if this card is in the deck
    if (!(id in deck.cards)) {
      return;
    }
    delete deck.cards[id];

    // put deck array back into storage
    saveDeck(deck, currentDeckID);
  }


  const addCardfromSinglecard = function() {
    // Wrapper for addCardToDeck(), to be called from singlecard.ejs

    // get name of Card from singlecard.ejs

    // TODO: put card ID into the html data attribute

    let card = {
      name: document.querySelector('.card-title')?.innerHTML,
      cardtype: document.querySelector('.card-type-text')?.getAttribute('data-cardtype'),
      info: 'ðŸ’¬',
      leader: false
    };
    addCardtoDeck(card);
    // hide the div that holds the "add to deck" function
    // TODO: animate instead
    document.getElementById('add-to-deck-container').style.display = "none";
  }


  const addCardFromDeckbuilder = function(row) {
    // Wrapper for addCardToDeck(), to be called from deck-builder.ejs

    // add the card from the deck builder
    let name = getInnerText(row.firstElementChild);
    
    let card = {
      name: getInnerText(row.querySelector('.table-cell-cardname')),
      id: row.dataset.cardid,
      cardtype: getInnerText(row.querySelector('.table-cell-cardtype')),
      info: 'ðŸ’¬',
      leader: false
    };
    addCardtoDeck(card);
  }


  const addCardAsLeader = function(row) {
    // Wrapper for addCardToDeck(), to be called from deck-builder.ejs

    // add the card from the deck builder
    let name = getInnerText(row.firstElementChild);
    
    let card = {
      name: getInnerText(row.querySelector('.table-cell-cardname')),
      id: row.dataset.cardid,
      cardtype: getInnerText(row.querySelector('.table-cell-cardtype')),
      info: 'ðŸ’¬',
      leader: true
    };
    addCardtoDeck(card);
  }


  const createDeckFromStorage = function() {
    // loads the deck from localstorage into the deck builder
    let deck = getDeck(currentDeckID);

    let galleryTBody = document.getElementById('card-gallery-table')
          .getElementsByTagName('tbody')[0];
    let deckTBody = document.getElementById('my-deck-table').getElementsByTagName('tbody')[0];
    let leaderTBody = document.getElementById('leader-container-table')
          .getElementsByTagName('tbody')[0];

    Object.entries(deck.cards).forEach(([key, card]) => {
      let row = document.querySelector(`.card-gallery-row-${key}`);
      if (!card.leader) {
        deckTBody.appendChild(row);
        addColumnsToCard(row);
      } else {
        // TODO: duplicate code, make it a function!
        // read image url from img tag
        let imageSrc = row.querySelector('.card-image-tooltip')?.src;

        let leaderImg = document.createElement('img');
        leaderImg.id = 'leader-image';
        leaderImg.src = imageSrc || 'images/notfound.png';
        leaderImg.width = '300';

        let dropZone = document.getElementById('leader-container');
        dropZone.appendChild(leaderImg);

        leaderTBody.appendChild(row);
        addColumnsToCard(row);
      }
    });

    // change Title
    let title = document.querySelector('#deck-title');
    title.textContent = truncateDeckName(deck.name) || 'Untitled Deck';
  }


  const getAllCards = async function() {
    // get all cards from Database
    let response = await fetch("/api/all-cards");
    let data = await response.json();

    cards = {};
    // reformat with id as keys
    data.forEach(card => {
      cards[card.id] = card;
    });

    return cards;
  }


  const download = function(content, fileName, contentType) {
    // generic client-side download
    let a = document.createElement("a");
    let file = new Blob([content], {type: contentType});
    a.href = URL.createObjectURL(file);
    a.download = fileName;
    a.click();
  }


  const exportDeckTxtNew = function() {
    const deck = getDeck(currentDeckID);
    let txt = '';
    let valid = true;  // if the deck is valid for export
    let errorMsg = [];

    // get leader name
    // TODO: leader has to be in the deck object
    const leader = getInnerText(document.getElementById('leader-container-table').getElementsByTagName('td')[0]);
    if (!leader) {
      valid = false;
      errorMsg.push('- Your deck has to have a Leader!');
    }
    txt += `//Leader\n${leader}\n\n//Deck\n`;

    Object.entries(deck.cards).forEach(([key, card]) => {
      if(!card.leader) {
        txt += `1 ${card.name}\n`;
      }
    });

    // add money from number input
    const money = document.getElementById('num-money').value;
    txt += `${money} Money`;

    // deck legality check (rows.length starting at one and the leader cancel out)
    let decklen = Object.entries(deck.cards).length + parseInt(money);
    if (decklen < 45) {
      valid = false;
      errorMsg.push(`- Your deck doesn\'t have enough cards (${decklen}/45)`);
    }

    if (!valid) {
      alert('Your deck is invalid for these reasons:\n' + errorMsg.join('\n'));
      return;
    }

    let filename = `${deck.name.replace(/[.\s]+/g, "_").toLowerCase()}.txt`;

    download(txt, filename, 'text/csv;charset=utf-8;');
  }


  const parseDeckString = async function(deckString, name="") {
    // split leader
    let parts = deckString.split('\n//');
    let matches = Array.from(parts[0].matchAll(/\/\/Leader\n(.*)\n/gm));
    let leader;
    if (matches.length > 0 && parts.length === 2) {
      leader = matches[0][1];
    } else {
      alert("Invalid Deck.");
      return [];
    }

    // put cards into list (number + card)
    let rawCards = parts[1].split('\n');
    rawCards = rawCards.slice(1, rawCards.length);
    // TODO: handle Money amount

    if (cardData === undefined) {
      // fetch the card data once (into RAM)
      cardData = await getAllCards();
    }
    let deck = getDeck(currentDeckID);

    deck.name = `Imported Deck (${name})`;

    let cards = rawCards.map(elem => elem.split(/[0-9]+\s/)[1]);
    cards.push(leader);
    
    cards.forEach(cardname => {
      // guess id from cardname
      let idGuess = cardname.toLowerCase().replace(/[.\s]+/g, "_");

      if (idGuess === 'money') {
        deck.money = deckString.match(/([0-9]+)\sMoney/)[1];
      } else {
        let card = {
          id: idGuess,
          leader: cardname === leader ? true : false
        };
        card.data = cardData[idGuess];
        deck.cards[idGuess] = card;

        if (card.leader) { deck.leader = card }
      }
    });
    saveDeck(deck, currentDeckID);
  }


  const updateStats = function() {
    // Update visualized deck statistics in the deck builder
    const money = parseInt(document.getElementById('num-money').value);

    let deck = getDeck(currentDeckID);
    const cardsTotal = Object.keys(deck.cards).length + money;

    let typeCount = {
      Fighter: 0,
      Item: 0,
      Landscape: 0,
      Challenge: 0
    };

    let totalHire = 0;
    let totalFire = 0;

    Object.entries(deck.cards).forEach(([key, card]) => {
      typeCount[card.cardtype]++;

      let hire = parseInt(card.data.hire);
      let fire = parseInt(card.data.fire);
      totalHire += Number.isFinite(hire) ? hire : 0;
      totalFire += Number.isFinite(fire) ? fire : 0;
    });

    let avgHire;
    if (cardsTotal === 0) {
      avgHire = "0"
    } else {
      avgHire = (totalHire / cardsTotal).toFixed(1);
    }

    let statsTxt1 = `Cards total: ${cardsTotal}<br>
    Fighters: ${typeCount.Fighter}<br>
    Items: ${typeCount.Item}<br>
    Landscapes: ${typeCount.Landscape}`;

    let statsTxt2 = `Challenges: ${typeCount.Challenge}<br>
    Money: ${money}<br>
    Average Hire costs: ${avgHire}<br>
    Total Fire costs: ${totalFire}`;

    document.getElementById('deck-stats').innerHTML = '';

    let p1 = document.createElement('p');
    let p2 = document.createElement('p');

    p1.innerHTML = statsTxt1;
    p2.innerHTML = statsTxt2;

    document.getElementById('deck-stats').appendChild(p1);
    document.getElementById('deck-stats').appendChild(p2);
  }


  const truncateDeckName = function(rawName, maxSize=30) {
    // truncates the deck name string for display
    if (rawName === null || rawName.length === 0) return "Untitled Deck";

    if (rawName.length <= maxSize) return rawName;

    return rawName.slice(0, maxSize) + '[...]';
  }


</script>
